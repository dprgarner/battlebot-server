<!DOCTYPE html>
<html>
<head>
  <title>Battle bot</title>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <style type="text/css">
    body {
      margin: 0;
      padding: 0;
    }
    .log {
      margin: 0;
      padding: 0;
      background-color: #ccc;
      vertical-align: top;
    }
    .half {
      display: inline-block;
      width: 49%;
    }
    .hoverer {
      position: fixed;
      top: 0;
    }
  </style>
</head>
<body style="margin:0;padding:0;">

<div class="hoverer">
<button onclick="connect('A')">Bot A</button>
<button onclick="connect('B')">Bot B</button>
<button onclick="playNumber(1)">+1</button>
<button onclick="playNumber(-1)">-1</button>
</div>
<div class="log">
  <h1>Info:</h1>
  <pre id="log-other"></pre>
</div>
<div class="log half">
  <h1>To Server:</h1>
  <pre id="log-out"></pre>
</div>
<div class="log half">
  <h1>From Server:</h1>
  <pre id="log-in"></pre>
</div>

<script type="text/javascript">
  function hex(buffer) {
    var hexCodes = [];
    var view = new DataView(buffer);
    for (var i = 0; i < view.byteLength; i += 4) {
      // Using getUint32 reduces the number of iterations needed (we process 4 bytes each time)
      var value = view.getUint32(i)
      // toString(16) will give the hex representation of the number without padding
      var stringValue = value.toString(16)
      // We use concatenation and slice for padding
      var padding = '00000000'
      var paddedValue = (padding + stringValue).slice(-padding.length)
      hexCodes.push(paddedValue);
    }

    // Join all the hex strings into one
    return hexCodes.join("");
  }

  function sha256(msg) {
    return crypto.subtle.digest('SHA-256', new TextEncoder('utf-8').encode(msg))
    .then(hash => hex(hash))
  }

  function logOther(msg) {
    console.log(msg);
    $('#log-other').text($('#log-other').text() + '\n' + msg);
  }

  function showMessage(msg) {
    console.log(msg);
    try {
      $('#log-in').text($('#log-in').text() + '\n' + JSON.stringify(msg, null, 2));
    } catch (e) {
      logOther(e.message);
      console.error(e);
    }
  }

  function sendMessage(ws, msg) {
    ws.send(JSON.stringify(msg));
    try {
      $('#log-out').text($('#log-out').text() + '\n' + JSON.stringify(msg, null, 2));
    } catch (e) {
      logOther(e.message);
      console.error(e);
    }
  }

  let connected = false;
  let ws = null;

  function playNumber(n) {
    sendMessage(ws, { type: 'turn', n });
  }

  function connect(botId) {
    if (connected) return;

    ws = new WebSocket(`ws://localhost:8080`);

    ws.onerror = (err) => logOther(err);
    ws.onopen = () => {
      logOther('WebSocket connection established');
      connected = true;
    };
    ws.onclose = () => {
      logOther('WebSocket connection closed');
      connected = false;
    }

    let authed = false;
    ws.onmessage = ({ data }) => {
      const dataObj = JSON.parse(data);
      showMessage(JSON.parse(data))
      if (!authed) {
        console.log(dataObj.salt);
        sha256("pass123" + dataObj.salt).then(function(digest) {
          console.log(digest);
          sendMessage(ws, { bot_id: botId, login_hash: digest, game: 'numberwang' });
          authed = true;
        });
      }
    };
  }
</script>

</body>
</html>